---
id: about-instance-performance-analysis
title: インスタンス性能管理の活用
description: アプリケーションモニタリングメニューの中でインスタンス性能管理メニューの主な機能と活用例を案内します。
keywords:
  - アプリケーション
  - アプリケーションモニタリング
  - APM
  - インスタンスの性能管理
toc_max_heading_level: 2
displayed_sidebar: learningSidebar
---

<Cmdname sid="side_agentsConfiguration" className="uitext" />メニューは、アプリケーションの環境を確認し、性能を管理するのに役立つ機能を提供します。 <Cmdname sid="side_agentsConfiguration" className="uitext" />でよく使用する主要メニューの詳細及び活用例を次のように案内します。

## ロード済クラス {#advanced-use-loaded-classes}

ホーム画面 &gt; プロジェクト選択 &gt; <Cmdname sid="side_agentsConfiguration" className="uitext" /> &gt; <Cmdname sid="side_loadedClasses" className="uitext" />

<Cmdname sid="side_loadedClasses" className="uitext" />メニューは、アプリケーションにロードされたクラスの構造とメソッドシグネチャーなどの詳細情報を提供し、また中断なくクラス動作を変更できるように<Cmdname sid="redefine" className="uitext" />機能を提供します。

#### 再定義

<Cmdname sid="redefine" className="uitext" />は、`Instrumentation`の`redefineClasses`メソッドを呼び出し、アプリケーションを中断させることなく、ランタイム中にすでにロードされたクラスの動作を変更できるようにします。 これは、運用中のサービスに対する修正や変更が必要な場合に役立ちます。 例えば、新しいサービスパターンの指定で追加のトランザクションの開始点を設定し、応答時間を測定しようとするとき、関連するWhaTap設定の変更後、そのクラスを<Cmdname sid="side_loadedClasses" className="uitext" />リストから探し![修正アイコン](/img/ico-edit.svg)アイコンをクリックして<Cmdname sid="redefine" className="uitext" />できます。

{/* 예를 들어 새로운 서비스 패턴 지정으로 추가적인 트랜잭션 시작점을 설정하여 응답 시간을 측정하는 등 트레이스 및 후킹과 관련된 와탭 설정 변경 시 해당 클래스를 목록에서 찾아 ![수정 아이콘](/img/ico-edit.svg) <Cmdname sid="redefine" className="uitext" />를 클릭하세요.  */}

<ImgLang img='best-p/about-instance-loaded-class1.png' desc='ロード済クラス再定義' />

{/* 해당 기능을 선택 해 재정의

再定義機能はredefine関数

既にローディングされたクラスを修正して新しいサービスパターンを指定し、追加でトランザクションの開始時点を設定できます。 これにより、応答時間を追跡できます。

서비스 패턴을 새로 지정해 새로운 트랜잭션 시작점을 설정하여 응답시간을 추적하고자 할 때  */}

#### リソース

<Cmdname sid="resource" className="uitext" />カラムを通じて、そのクラスが物理的にどのファイルからロードされたかを照会できます。 Javaアプリケーションの多階層構造の特性上、このような<Cmdname sid="resource" className="uitext" />情報の確認が必要です。 複雑なアプリケーション環境では、クラスが正確にどのような*jar*ファイルからロードされているかを把握することが重要です。

特定のクラスが意図しない*jar*ファイルからロードされた場合、予期しない動作やバグが発生する可能性があります。 特に、複雑なクラスパスやマルチモジュール環境では、正確にどの経路でロードされたかを確認して、容易なデバッグが可能です。 

{/* 으로 클래스간 충돌 방지, 디버깅, 성능 최적화 등을 도울 수 있습니다.  */}

{/* \* **클래스 충돌 방지** 

  サードパーティライブラリの様々なバージョンで、同じクラスが複数の*jar*ファイルに存在する可能性があります。 重複したクラスを識別し、優先順位を調整して衝突が発生する*jar*ファイルを明示的に除外または特定のファイルを含むなどの措置で、クラスの衝突を防止できます。  */}

  {/* 
  この時、クラスが正確にどの*jar*ファイルで読み込みされていることを確認し、クラスの衝突を防止できます。 同じクラスが複数の*jar*ファイルで読み込みされるのを防止できます。 
  様々なバージョンのサードパーティライブラリが読み込みされるなど、同じクラスが複数の*jar*ファイルに存在する場合、クラスが正確にどのような*jar*ファイルで読み込みされていることを確認することで、クラスの衝突を防止できます。  */}

{/* \* **디버깅** 

  特定のクラスが意図しない*jar*ファイルからロードされた場合、予期しない動作やバグが発生する可能性があります。 特に、複雑なクラスパスやマルチモジュール環境では、正確にどの経路でロードされたかを確認して、容易なデバッグが可能です。   */}

{/* \* **성능 최적화** 

  クラスの読み込みが性能問題の原因になる可能性があります。 クラスがどの*jar*ファイルで過度に読み込みされるかを確認した後、よく使用されるクラスを含む*jar*ファイルが適切な位置で読み込みされるようにクラスパスを調整して、そのクラスの読み込み時間を最適化できます。  */}

  {/* 
  クラスがどの*jar*ファイルで過剰に読み込みされるかを確認して、性能を最適化できます。
  クラスローディング時に性能問題が発生する場合、どのような*jar*ファイルからクラスが過剰にロードされているかどうかを把握することで、性能を管理できます。  */}

{/* 자바 애플리케이션의 다계층 구조 특성상 <Cmdname sid="resource" className="uitext" /> 정보 확인이 필요합니다.  */}

## スレッドリスト/ダンプ {#advanced-use-thread-list-dump}

ホーム画面 &gt; プロジェクト選択 &gt; <Cmdname sid="side_agentsConfiguration" className="uitext" /> &gt; <Cmdname sid="side_threadList" className="uitext" />

{/* 

스레드 목록을 보고 하는 중요한 행위-> 스레드 cpu 누적 시간 보여줌 -> 시계열 정보 확인 가능하다는 얘기를 추가하기 

*/}

<Cmdname sid="side_threadList" className="uitext" />メニューは、現在実行中のスレッドのリストを確認し、そのスレッドの個々のスナップショット及び全体のスレッドダンプ情報を照会できます。 <Cmdname sid="hitmap" className="uitext" />がトランザクション応答時間中心の最適化作業の核心であれば、<Cmdname sid="side_threadList" className="uitext" />はCPU最適化の核心要素と言えます。これはアプリケーションの性能最適化、問題診断、そして安定性維持に重要な役割を果たします。

どのスレッドがCPUを多く使用しているかを把握することは、ボトルネックの発生原因を識別する上で重要です。 特に、特定の時間帯にCPU使用が急増したスレッド識別のために、時系列データを照会できる必要があります。 <Cmdname sid="side_threadList" className="uitext" />メニューの<Cmdname sid="thread_cpu_time" className="uitext" />は、当該スレッドがCPUを占有した合計累積時間を意味します。 ***更新***時、現在のスレッドCPU時間と既存のスレッドCPU時間の差である<Cmdname sid="TTL08126" className="uitext" />を提供することで、照会時点で最も多くCPUを使用しているスレッドを特定できます。 <Cmdname sid="TTL08126" className="uitext" />カラムをクリックし、降順でのソートで増加量が最も高いスレッドを確認してみてください。 

<ImgLang img='best-p/about-instance-thread-list-dump3.png' desc='スレッドリスト/ダンプデルタ値' />

このようにスレッドを特定した後、そのスレッドのスナップショットを確認して、頻繁に呼び出されたり、長く実行されるメソッドなどを確認できます。 これにより、異常な兆候を早期に発見し、対応してシステムを安定的に管理できます。

<ImgLang img='best-p/about-instance-thread-list-dump4.png' desc='スレッドリスト/ダンプ個別スレッドダンプ' />

{/* :::note 

例のスレッドは`RequestQueue`で要素を読み込もうとして例外が発生して`wait`が呼び出された可能性があります。 スナップショット情報に基づいて待機状態が発生した原因を確認します。

- `RequestQueue.get`メソッドの58行目を確認し、どの条件で`wait`が呼び出されるか確認します。 

- `ZipSendProxyThread.run`メソッドの54行目を確認し、どの状況で`RequestQueue.get`メソッドを呼び出されるか確認します。

::: */}

#### CPU使用量の高いスレッドの確認

アプリケーションCPU使用量が急増した場合は、様々な原因に起因する可能性があります。 これを、ヒープメモリがいっぱいの場合、実際のリクエストが多い場合、そしてロジックの問題の場合の3つのタイプに分類できます。

このとき、最初に確認するのは識別しやすいヒープメモリです。 ヒープメモリがいっぱいになった場合、JVMがGCを頻繁に実行し、CPU使用量が急増する可能性があります。 この場合、<Cmdname sid="application_dashboard" className="uitext" />の<Cmdname sid="AA010" className="uitext" />グラフで簡単に確認できます。 2つ目は、実際のリクエストが多いことで、アプリケーションが多い数のクライアントリクエストを処理し、CPU使用量が高くなった場合です。 各リクエストはJavaスレッドを生成して処理されるため、CPUが多くの作業を行うことになります。 この場合、<Cmdname sid="application_dashboard" className="uitext" />でTPS関連指標を通じて確認できます。

3つ目は、アプリケーションコードに非効率的なアルゴリズムや無限ループなどが含まれている場合、CPU使用率が異常に高くなる可能性があります。 この場合、<Cmdname sid="side_threadList" className="uitext" />メニューを通じてCPU使用量が高いスレッドを特定した後、該当スレッドダンプを確認して問題になるコードを確認できます。

:::note 

<Cmdname sid="thread_cpu_time" className="uitext" />確認→ <Cmdname sid="refresh" className="uitext" /> → <Cmdname sid="TTL08126" className="uitext" />基準でリストをソート→ **CPU使用量の高いスレッドの識別**

:::

{/* 

どのスレッドがCPUを多く使用しているのか、またはどのスレッドがブロックされた状態なのかを把握することは 

どのスレッドがCPUを多く使用しているのか、またはどのスレッドがブロックされた状態なのかを把握してボトルネックを引き起こす原因を識別できます。 スレッドを特定した後、そのスレッドスナップショットを通じて、頻繁に呼び出されたり、長く実行されるメソッドなどを確認できます。 */}

{/* ### 증가량 

![スレッドリスト/ダンプ](/img/best-p/about-instance-thread-list-dump1.png)

![스레드 목록/덤프 델타값](/img/best-p/about-instance-thread-list-dump2.png) */}

{/* ## 소켓 오픈 개수 {#advanced-use-opened-socket-count} */}

{/* 이때 가장 먼저 확인하는 것은 식별이 용이한 힙 메모리입니다. ヒープメモリがいっぱいになった場合、JVMがGCを頻繁に実行し、CPU使用量が急増する可能性があります。 ~~特に、Full GC発生時にアプリケーションが一時的に停止し、CPU使用量が大幅に上昇します。 例えば、アプリケーションでオブジェクトが適切に解除されず、メモリを占有するメモリ漏れが発生した場合、ヒープメモリが不足する可能性があり、この時、メモリを回収するためにJVMがGCを繰り返し実行し、CPU使用率が急激に増加します。~~この場合<Cmdname sid="application_dashboard" className="uitext" />の<Cmdname sid="AA010" className="uitext" />グラフで簡単に確認できます。 

2つ目は、実際のリクエストが多いことで、アプリケーションが多い数のクライアントリクエストを処理し、CPU使用量が高くなった場合です。 各リクエストはJavaスレッドを生成して処理されるため、CPUが多くの作業を行うことになります。 ~~ショッピングモールサイトの大規模な割引イベントなどで、ウェブユーザーのトラフィックが急増したケースが一つの例です。 多くのユーザーがWebページを訪問し、サーバーが多数のHTTPリクエストを処理するために、同様に多くのスレッドを生成し、CPU使用率が大幅に上昇します。~~この場合<Cmdname sid="application_dashboard" className="uitext" />でTPS関連メトリクスを通じて確認できます。

3つ目は、間違ったコードロジックで問題が発生した場合です。 アプリケーションコードに非効率的なアルゴリズムや無限ループなどが含まれている場合、CPU使用率が異常に高くなる可能性があります。 この場合、<Cmdname sid="side_threadList" className="uitext" />メニューを通じてCPU使用量が高いスレッドを特定した後、該当スレッドダンプを確認して問題になるコードを確認できます。 */}
